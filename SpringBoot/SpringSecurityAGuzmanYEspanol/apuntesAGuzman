Con respecto al proyecto de springsecurity del español (crudBack), este proyecto ocupa OAUTH2, cosa que no hace el español. 
Con respecto al proyecto de springsecurity de Barath, ocupa GranType password y el español ocupa GranType Authorization code. Ambos usan OAUTH2.

Un JWT nuevo se crea cada vez que un usuario se loguea exitosamente, y estará vigente mientras dure la sesión se usuario. En cada petición http el usuario deberá pedir el recurso requerido junto con el JWT al servidor.
El Header contiene el tipo de algoritmo, el payload contiene la data del usuario. sub=nombre de usuario en la aplicacion (musiciancoder), name=nombre real, iat=data adicional como por ejemplo fecha de registro, email, etc. Se puede naturalmente ir agregando mas campos en este json sin ningun problema; 
La firma (verify signature) contiene el código secreto (your-256-bit-secret). Recordar q el resource server tiene la llave privada para el signature, pero no la app cliente.
Los otros elementos (header y payload) se agregan al codigo secreto, se codifican en base 64 y esto es la firma. 
En el sitio web de JWT, si intentamos modificar algo directamente en el JWT, nos aparecerá "invalid signature", pero naturalmente que sí se puede modificar los datos payload (o el tipo de algoritmo) sin problemas, en cuyo caso cambia los numeros del payload, pero sigue siendo válido. Acá tambien podemos revisar el session storage y local storage.
Cualquier JWT en el sitio web se puede decodificar en la consola (aunque creo yo q esto no debiera ser posible porque vulneraria la seguridad), por lo que JWT es facilmente codificable y decodificable en ambos sentidos, por lo que es importante no guardar informacion sensible en el payload, ya que faclmente alguien lo podría ver.

0.Habló sobre la arquitectura de OAUTH2, con servidor de autorizacion y servidor de recurso con respecto a aplicacion cliente. Agregó las dependencias de spring-security-oauth2 y de jwt. A partir de java 9 javaxb-api y javaxb-runtime.
1.Creó las entidades Usuario y Role (ver proyecto spring-boot-backend-apirest) para que al correr la app se creen estas tablas. Ademas hay una tabla intermedia de usarios_roles creada con la anotacion @JoinTable.
2.Creó el patrón DAO (implementando CRUDRepository) con IusuarioDAO, pero sin clase implementadora, sino que la inyectó directamente en la clase de servicio UsuarioService.
Esta clase implementa UserDetailsService, con su metodo obligatorio UserDetails loadUserByUserName, devolviendo un tipo UserDetails, que contiene las autorizaciones del usuario (GrantedAuthorities).
3.Creó la clase de configuracion de Spring Security SpringSecurityConfig que extiende WebSecurityConfigurerAdapter, donde inyectó nuestro servicio UserDetails. Creó los beans BCryptPasswordEncoder y AuthenticationManager. Esta clase la siguió escribiendo en videos posteriores. Esta clase la tiene el proyecto del español, aunque se llama MainSecurity y hace basicamente lo mismo.
4.Creó la clase de configuracion del servidor AuthorizationServerConfig que extiende AuthorizationServerConfigurerAdapter. Esta clase se encarga de configurar las autorizaciones (de endpoints, por ejemplo). Acá inyectó BCryptPasswordEncoder y AuthenticationManager de la clase SpringSecurityConfig. Esta clase NO la tiene el proyecto del español
5.Creó la clase de configuracion para el servidor de recursoResourceServerConfig que extiende ResourceServerConfigurerAdapter. Esta es básicamente la configuración de OAUTH2 para accesos a rutas protegidas. Esta clase NO existe en el proyecto del español, la configuracion de los antMatchers la hiso en la clase MainSecurity.
6.Creó algunos usuarios con sus roles por medio de sql. Esto lo hizo al correr la aplicacion, con el script sql que está en el proyecto en resources-->import.sql
7.Probó en postman. Partió probando con un GET localhost:8080/api/clientes y entró sin problemas ya que la configuración de la clase ResourceServerConfig se lo permitía debido al metodo permitAll(). Luego volvió a probar con get para localhost:8080/api/clientes/1 y no pudo entrar porque necesitaba el token.  Los usuarios creados necesitan passwords encriptados en la bbdd (spring security requiere esto) para poder probar en postman. Esto lo obtuvo en SpringBootBackendApirestApplication implementando CommandLineRunner y escribiendo unas lineas de codigo adicionales para enciptar el password="12345". Al correr la app en el log obtuvo 5 passwords encriptados (q son los tremendos chorizos) y los pegó para cada usuario en el import.sql en la bbdd. 
Para generar un token de autenticacion en postman, lo hizo con la ruta localhost:8080/oauth/token, que es la ruta por defecto de OAUTH2. Luego en el body escribió el username (andres), el password sin encriptar (12345) y el grant_type (password).
En Authorization en el postman seleccionamos basic auth y escribimos las credenciales de la app cliente, en nuestro caso Username=angularapp y Password=12345 (uso la misma contraseña para usuario y app cliente, pero normalmente debieran ser distintas)
Luego en el Authorization hacemos click en "Preview Request" y notaremos que en el Header ya tendremos escrito una clave (Authorization) valor encriptado (Basic HFYEhdt5h6DBBFB==).
Damos click en send y obtenemos el access token. Volvemos a probar la ruta localhost:8080/api/clientes/1 con get, pero antes del send seleccionó Bearer Token en Authorization, hizo click en "Preview Request" y obtuvo la clave valor en el header. Hizoclick en send y ahi ya tuvo acceso a ver el id:1, "nombre":"Andres","apellido":"guzman", etc. Probó los otros verbos de REST y vió q funcionaban.
Luego cortó el token y lo pegó en el sitio web de JWT, con lo que obtuvo header,payload y signature. Notaremos que en el payload va el user_name, los roles pero no así el password 12345, lo q esta muy bien creo yo.
8.Hasta el momento hemos trabajado sin llaves publicas o privadas en forma explicita en el codigo para acceder al token porque hemos venido usando un tipo de algoritmo (tipo HSA) cuyas llaves las setea la api por defecto. Sin embargo es mas seguro definir un algoritmo en el que nosotros controlemos las llaves.
Para ello creó el bean JwtAccessTokenConverter en la clase AuthorizationServerConfig. Esto es para que nosotros podamos escribir nuestra llave secreta (la llave privada firma el JWT con el signature en el servidor de autorizacion y la publica es para que el servidor de recursos pueda verificar esta firma (o sea q el token sea autentico) ) según el tipo de algoritmo (mac=tipo de algoritmo) que hemos seleccionado. 
En nuestro caso el decidió que el mac va a ser tipo RSA, por lo que necesitó proveer en el código un string para llave secreta ("alguna.clave.secreta.12345678"). 
Luego volvió a generar un token en postman segun el paso anterior.
9.Para robustecer la seguridad cambió la llave secreta anterior ("alguna.clave.secreta.12345678") a dos llaves secretas en el código, una publica y otra privada generadas por OpenSSL (existen mas medios de generar llaves secretas, como keytool y keygen, de hecho lo menciona pero él ocupa esta).
Pegó ambas llaves en metodo accessTokenConverter() de la clase AuthenticationManager.
Generó un nuevo token según los pasos anteriores y volvió a probar el acceso a localhost:8080/api/clientes/1 en forma exitosa. Notar que el nuevo token al pegarlo en el sitio de JWT en la parte del signature va a salir ahora dos inputs para insertar llave publica y privada. 
10.Luego quiso ver informacion de usuario adicional a la que se ve por defecto en el payload al pegar el token en el sitio web de JWT.
Para ello creo la clase InfoAdicionalToken implementa TokenEnhancer (no esta en el proyecto del español) y escribió como clave valor la info adicional. Para ello necesitaba tener un usuario en esta clase, pero no quiso ocupar el findById en servicio que ya tenía (esto lo hizo mas que nada para no mezclar las cosas), razón por la que creó la interfaz personalizada IUsuarioService (diferente a UserDetailsService que es la q ya estaba de Spring) y la implementó en UsuarioService (doble implementacion de ambas interfaces mencionadas) y finalmente la inyectó en InfoAdicionalToken.
A continuación registró el cambio para los endpoints en la clase AuthorizationServerConfig.
Finalmente generó un nuevo token en postman y lo pegó en el sitio web de JWT. Entonces en el payload vio la info adicional la info adicional tipo clave valor para el usuario.
11.Creo info adicional para usuarios con nombre, apellido e email en entity (antes solo tenía id, username y password). Modificó InfoAdicionalToken para q mostrara en los logs. Generó un token nuevo, lo pegó en el sitio de jwt y observó q estaba la info adicional en el payload (sigue no saliendo el password, lo q segun yo esta muy bien). 
12.Configuró los permisos según roles de usuario o administrador en la clase ResourceServerConfig (metodo configure, lo hizo con los antMatchers para cada verbo REST). Probó en Postman los accesos generando un token para administrador (con username=admin) y probando las rutas, luego se generó otro token para usuario (con username=andres) y comprobó que no tenía todos los accesos a rutas.
13.Comentó los antMatchers en la clase SpringSecurityConfig porque explicó otra alternativa para dar accesos segun roles: escribir @EnableGlobalMethodSecurity(securedEnabled = true) en clase SpringSecurityConfig y @Secured("ROLE_ADMIN") en cada método a proteger en la clase ClienteRestController
14.Probó desde Angular y vió que no tenía acceso debido a los CORS. Para solventarlo, en la clase ResourceServerConfig se creó un bean para la configuración de los CORS (el método guardado como bean es corsConfigurationSource), el cual fue pasado en en método configure de esta misma clase.
Adicionalmente se creó un filtro (metodo corsFilter). Este filtro es ocupado tanto al generar el token con localhost:8080/oauth/token como en las peticiones al pedir recursos ya estando autenticados con nuestro token



COMPARANDOLO CON EL CURSO DE SPRING SECURITY DEL INDIO BHARATH DE UDEMY:
At the intro, he says;
We can manage security for our app by using "sessions", which comes in handy when we got backend + frontend whithin the same app (by using thymeleaf, for example). Sessions are stateful. We got a discrepancy at this point
with barath, since barath did his whole Secure Web App with token validation in the login() method eventhou he did not use tokens on any requests at this point. I asked Barath.
Barath added password on the payload, which contradicts line 7. We should see how Guzman handles password inside (or outside) the payload to have clarity.
In lesson "Creando la clase de servicio UsuarioService" he implements form UserDetailsService overriding loadByUserName.
En el curso, Guzman menciona lo siguiente:
"En Spring Boot 3, Spring Security 6 (y usando JAVA 17 o 19), así como otros métodos de configuración para proteger las solicitudes (a saber, y ) se han eliminado de la API. antMatchers() mvcMathcers() regexMatchers()
Se introdujo un método sobrecargado requesMatchers() como un medio uniforme para asegurar las solicitudes. Los sabores de facilitan todas las formas de restringir las solicitudes que fueron admitidas por los métodos eliminados.requesMatchers()
Además, el método authorizeRequests() ha quedado obsoleto y ya no debe usarse, ahora en Spring Boot 3 se usa authorizeHttpRequests(). Pero insisto que es muy probable que Spring OAuth2 no sea compatible con Spring Boot 3 y en ese caso mejor es bajar de versión de spring boot 2.5.14 por mientras ya que todavia se mantiene en paralelo y tiene soporte por el equipo de spring."
La frase anterior lleva a pensar que el codigo del curso del Indio en la clase WebSecurityConfig2 (q no implementa WebSecurityConfigurerAdapter) esta okey y en todo caso OAUTH2 si tiene compatibilidad con springboot3. En cambio la clase WebSecurityConfig del indio es la equivalente a SecurityConfig de Guzman, ya q ambas clases extienden de WebSecurityConfigurerAdapter q obliga a sobreescribir los configure y que un usuario menciona sabiamente en las preguntas que esta deprecado y Guzman deberá regrabar los videos en un futuro.
La clase de configuracion del servidor AuthorizationServerConfig que extiende AuthorizationServerConfigurerAdapter (esta ultima estoy casi seguro q esta deprecada tambien) esta completamente diferente a la de barath (o sea la clase AuthorizationServerConfiguration). Mucho mas confiable la de Bharath, sobretodo para versiones posteriores a Spring 3.0.
En la seccion "añadiendo configuracion de las autorizaciones..." explicó que el GranType que usa no es Authorization Code (lo menciona brevemente), sino que es de tipo Password y Refresh-Token, con lo q infiero q el logueo se hace en Angular y no en el Authorization Server.
Ocupa SSH para generar las llaves publica y privada, en cambio barath ocupa keytool.
