Unit Test --> Se prueban módulos aislados. Junit + Mockito. Los hace el desarrollador
Component Test-->Se prueban componentes específicos (como Service, Controller, etc.).  Los hace el desarrollador. Muy similar a Unit Test (se puede hacer con Junit y Mockito), pero con algunas salvedades. Ver https://stackoverflow.com/questions/51789880/how-to-test-a-component-bean-in-spring-boot
Integration Test-->Se prueban grupos de módulos en conjunto. Librerias Jupiter + Junit + Mockito. Los hace el desarrollador. https://www.baeldung.com/integration-testing-in-spring
System Test-->Se prueba la aplicación final desde varios aspectos. Los hace el QA. E2E Test es un tipo de System Test (el mas importante) que prueba desde el aspecto de usuario final, pero hay otros como blackbox test, smoke test, etc. https://www.softwaretestinghelp.com/types-of-software-testing/#3_System_Testing 
E2E Test-->Se prueba desde el punto de vista del usuario final. Los hace el QA con Autify, QAWolf, etc.
Performance Test-->Se prueba el rendimiento de la app. Los hace el QA con Jmeter, etc. Se subdividen al variar las condiciones de carga en Load testing, Stress testing y Scalability test.
Penetration Test-->Test de seguridad realizado con Fortify y otros software por una persona que intencionalmente desea entrar al sistema. Puede ser realizado por el desarrollador dependiendo de la empresa.
Vulnerabilities Scan-->Test de seguridad de rutina, generalmente automatico realizado por el software (Fortify por ejemplo) cada intervalos de tiempo.  
Acceptance Test-->Se conocen como UAT. Es la aceptacion final de la funcionalidad generalmente hecha por el PO. Se hacen con herramientas de naturaleza blanda como Marker, Test Monitor.
Functionality Test -->Segun yo estos son los Behaviour Driven Design (BDD). Los BDD se llevan a cabo con Cucumber y Selenium.   
Behavior-driven development (BDD)-->Lo hacen en conjunto el desarrollador el QA y a veces el PO. Se lleva a cabo con herramientas como Cucumber. It is an agile software development process that encourages collaboration among developers, quality assurance experts, and customer representatives in a software project.[1][2][3] It encourages teams to use conversation and concrete examples to formalize a shared understanding of how the application should behave.[4] It emerged from test-driven development (TDD).[1][2][5][6][vague][7] Behavior-driven development combines the general techniques and principles of TDD with ideas from domain-driven design and object-oriented analysis and design to provide software development and management teams with shared tools and a shared process to collaborate on software development.[2][7] 